import sys

import numpy
import numpy.linalg
import scipy
import scipy.spatial
import mahal_dist



# Returns a clustering of all the N observations.
# dist_m is a NxN matrix whereas each entry dij specifies the
# distance between observation i and observation j.
# k is the number of clusters
def cluster_by_dist(points, k):

    clusters = []
    clusters.append(points[numpy.random.randint(0,points.shape[0])])

    partition = numpy.array(0)
    partition.resize(points.shape[0])
    
    dist_to_cluster = None
    
    for i in xrange(1,k):
        dist_m = scipy.spatial.distance.cdist([clusters[-1]], points)

        if dist_to_cluster == None:
            dist_to_cluster = dist_m
        else:
            dist_to_cluster = numpy.min([dist_m,dist_to_cluster],axis=0)
        max_dist = 0.0
        max_j = 0
        for j in xrange(dist_to_cluster.shape[1]):
            if dist_to_cluster[0,j] > max_dist:
                max_j = j
        clusters.append(points[j])

    clusters = numpy.array(clusters)


    dist_m = numpy.array(0.0)
    dist_m.resize(clusters.shape[0], points.shape[0])

    cluster_mean = numpy.array(0.0)
    cluster_mean.resize(clusters.shape[0])
    cluster_mean_count = numpy.array(0)
    cluster_mean_count.resize(clusters.shape[0])

    print 'cluster_mean_count:'
    print cluster_mean_count
    print 'cluster_mean:'
    print cluster_mean
    
    iterations = 0
    SWAP_THRESHOLD = 0
    swaps = sys.maxint
    while swaps > SWAP_THRESHOLD:

        swaps = 0
    
        dist_to_clusters = scipy.spatial.distance.cdist(clusters,points)
        
        for i in xrange(points.shape[0]):
            row = dist_to_clusters[:,i]
            min_dist = 0.0
            min_j = -1
            for j in xrange(row.shape[0]):
                if row[j] < min_dist or min_j == -1:
                    min_dist = row[j]
                    min_j = j
            if partition[i] != min_j:
                swaps += 1
                partition[i] = min_j\

        if swaps <= SWAP_THRESHOLD:
            #print 'cluster_mean_count:'
            #print cluster_mean_count
            #print 'cluster_mean:'
            #print cluster_mean
            continue
            
        # calculate center with mahalanobis distance
        old_cluster_mean = clusters.copy()
        cluster_mean = numpy.zeros(clusters.shape, float)
        cluster_mean_count = numpy.zeros(clusters.shape[0], int)
        for i in xrange(points.shape[0]):
            cluster_mean[partition[i]] += points[i]
            cluster_mean_count[partition[i]] += 1
        cluster_mean = (cluster_mean.transpose() / cluster_mean_count).transpose()
        for i in xrange(cluster_mean_count.shape[0]):
            if cluster_mean_count[i] == 0:
                cluster_mean_count[i] = 1
                cluster_mean[i] = old_cluster_mean[i]
        #print 'cluster_mean_count:'
        #print cluster_mean_count
        #print 'cluster_mean:'
        #print cluster_mean
        clusters = cluster_mean
        iterations += 1

    print 'iterations=%d' % iterations
    
    return partition, clusters








