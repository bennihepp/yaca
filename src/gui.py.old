import sys, os, random
from PyQt4.QtCore import *
from PyQt4.QtGui import *

import numpy
import struct
import Image
import ImageChops
#import ImageQt
import libtiff

import matplotlib
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar
from matplotlib.figure import Figure
from matplotlib import pyplot


TMP_IMAGE_FILENAME_TEMPLATE = '/dev/shm/adc-tmp-image-file-%d.tiff'


class GalleryWindow(QWidget):

    GRID_SPACING = 4
    LABEL_MARGIN = 0

    def __init__(self, channelDescription, parent=None):
        super(QWidget,self).__init__(parent)
        self.setWindowTitle('APC Gallery')

        self.tmp_image_filename = TMP_IMAGE_FILENAME_TEMPLATE % ( numpy.random.randint(sys.maxint) )

        self.min_pixmap_width = 96
        self.min_pixmap_height = 96

        self.pixmap_width = self.min_pixmap_width
        self.pixmap_height = self.min_pixmap_height

        self.selectionIds = None

        self.pixmaps = []
        self.widgets = []
        self.channelBoxes = {}

        self.channelDescription = channelDescription

        #self.create_menu()
        self.create_frame()

    def cmp_channels( c1, c2 ):
        if c1 == c2:
            return 0
        if c1 == 'R': return -1
        if c2 == 'R': return +1
        if c1 == 'G': return -1
        if c2 == 'G': return +1
        if c1 == 'B': return -1
        if c2 == 'B': return +1
        return cmp( c1, c2 )

    def on_selection_changed(self, focusId, selectionIds, pixmapFactory):

        self.focusId = focusId
        self.selectionIds = selectionIds
        self.pixmapFactory = pixmapFactory
        self.focus_i = -1
        for i in xrange(selectionIds.shape[0]):
            if selectionIds[i] == focusId:
                self.focus_i = i
                break
        self.start_i = max( 0, self.focus_i - len(self.widgets) / 2 )
        self.stop_i = min( self.start_i + len(self.widgets), selectionIds.shape[0] )
        self.on_reload_images( self.start_i, self.stop_i, self.focus_i )

    def on_reload_images(self, start_i, stop_i, focus_i=-1):

        if self.selectionIds == None:
            return

        del self.pixmaps[ : ]

        for i in xrange( start_i, stop_i ):

            try:
                pix = self.pixmapFactory( self.selectionIds[i], self.pixmap_width, self.pixmap_height, self.channelSelection, self.tmp_image_filename )
                #print id(pix)

                if pix:
                    self.pixmaps.append(pix)
                    self.widgets[i-start_i].setText('Label #%d' % (i))
                    self.widgets[i-start_i].setPixmap(pix)
                    if i == self.focus_i:
                        self.widgets[i-start_i].setFrameStyle(QFrame.Panel or QFrame.Raised)
                        self.widgets[i-start_i].setLineWidth(2)
                    else:
                        self.widgets[i-start_i].setFrameStyle(QFrame.NoFrame)

                else:
                    self.widgets[i-start_i].setText('No image files available')
                    self.pixmaps.append(None)
                    self.widgets[i-start_i].setFrameStyle(QFrame.Panel or QFrame.Raised)
                    self.widgets[i-start_i].setLineWidth(2)

                """
            if channels:
                try:
                    print '<0>'
                    rect = rectSelector( selectionIds[i] )
                    if channels.has_key('R'):
                        img = Image.open( channels['R'] )
                        img_red = img.crop( rect )
                        img_red = image_convert_16_to_8_bit( img_red )
                        del img
                    else:
                        img_red = Image.new( 'L', ( (rect[2]-rect[0]) , (rect[3]-rect[1]) ) )
                    if channels.has_key('G'):
                        img = Image.open( channels['G'] )
                        img_green = img.crop( rect )
                        img_green = image_convert_16_to_8_bit( img_green )
                        del img
                    else:
                        img_green = Image.new( 'L', ( (rect[2]-rect[0]) , (rect[3]-rect[1]) ) )
                    if channels.has_key('B'):
                        img = Image.open( channels['B'] )
                        img_blue = img.crop( rect )
                        img_blue = image_convert_16_to_8_bit( img_blue )
                        del img
                    else:
                        img_blue = Image.new( 'L', ( (rect[2]-rect[0]) , (rect[3]-rect[1]) ) )
                    mode = 'RGB'
                    img = Image.merge( mode, (img_red,img_green,img_blue) )
                    img_size = img.size
                    del img_red,img_green,img_blue

                    #i1 = Image.open(filename)
                    #print '<1>'
                    #i2 = i1.crop(rectSelector(selectionIds[i]))
                    print '<2>'
                    arr = numpy.array(img.getdata())
                    del img
                    print '<3>'
                    tmp_str = struct.pack('@%dh' % len(arr), *arr)
                    print '<4>'
                    arr = numpy.array(struct.unpack('@%dH' % len(arr), tmp_str))
                    del tmp_str
                    print '<5>'
                    arr = arr - 2**15
                    arr = arr * (2**8-1.0)/(2**12-1.0)
                    #a3 = a3 >> 4
                    print '<6>'
                    tmp_str = struct.pack('@%dB' % len(arr), *arr)
                    print '<7>'
                    img = Image.fromstring('L',img_size,tmp_str,"raw","L",0,1)
                    del tmp_str
                    print '<8>'
                    img.save(self.tmp_image_filename)
                    print '<9>'
                    del img
                    #qtimg = QImage('/home/benjamin/tmp.tif')
                    #qtimg.save('/home/benjamin/tmp_img.tif')

                    #i1 = libtiff.TIFF.open(filename)
                    #a1 = i1.read_image()
                    #a1 = a1 - 2**15
                    #a1 = a1 * ( 2**8 - 1.0 ) / ( 2**12 - 1.0 )


                    #tmp = Image.open(filename)
                    #img = tmp.crop(rectSelector(selectionIds[i]))
                    #img.save('/home/benjamin/tmp.tiff')
                    #img2 = img.convert("L")
                    #img2.save('/home/benjamin/tmp2.tiff')
                    #del img
                    #del tmp
                    #qtimg = ImageQt.ImageQt(img2)
                    
                    #rect = rectSelector(selectionIds[i])
                    #tmp = QImage(filename)
                    #qtimg = tmp.copy(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
                    #del tmp
    
                    #pix = QPixmap.fromImage(qtimg)
                    #pix.save('/home/benjamin/tmp_pix.png')
                    #del qtimg
    
                    #rect = rectSelector(selectionIds[i])
                    #tmp = QPixmap(filename)
                    #pix = tmp.copy(rect[0], rect[1], rect[2]-rect[0], rect[3]-rect[1])
                    #del tmp
    
                    pix = QPixmap(self.tmp_image_filename)
                    print '<10>'
                    self.pixmaps.append(pix)
                    print '<11>'
                    self.widgets[i-start_i].setPixmap(pix)
                    print '<12>'"""

            except IOError:
                self.widgets[i-start_i].setText('Invalid filenames')
                self.pixmaps.append(None)
                self.widgets[i-start_i].setFrameStyle(QFrame.Panel or QFrame.Raised)
                self.widgets[i-start_i].setLineWidth(2)

            except:
                self.widgets[i-start_i].setText('Invalid image files')
                self.pixmaps.append(None)
                self.widgets[i-start_i].setFrameStyle(QFrame.Panel or QFrame.Raised)
                self.widgets[i-start_i].setLineWidth(2)
                raise
            finally:
                if os.path.isfile( self.tmp_image_filename ):
                    os.remove( self.tmp_image_filename )

    def on_previous(self):
        if self.start_i > 0:
            self.stop_i = self.start_i - 1
            self.start_i = max( 0, self.stop_i - len(self.widgets) )
            self.on_reload_images( self.start_i, self.stop_i, self.focus_i )
    def on_next(self):
        if self.stop_i + 1 < self.selectionIds.shape[0]:
            self.start_i = self.stop_i + 1
            self.stop_i = min( self.start_i + len(self.widgets), self.selectionIds.shape[0] )
            self.on_reload_images( self.start_i, self.stop_i, self.focus_i )

    """def calculate_pixmap_size(self):
        if self.columns > 1:
            self.pixmap_width = ( self.size().width() / self.columns - self.GRID_SPACING / (self.columns-1) )
        else:
            self.pixmap_width = self.size().width() / self.columns
        #if self.pixmap_width % 2 != 0:
        #    self.pixmap_width -= 1
        if self.rows > 1:
            self.pixmap_height = ( self.size().height() / self.rows - self.GRID_SPACING / (self.rows-1)  )
        else:
            self.pixmap_height = self.size().height() / self.rows
        #if self.pixmap_height % 2 != 0:
        #    self.pixmap_height -= 1

    def resizeEvent(self, event):

        print 'resizeEvent'

        self.calculate_pixmap_size()

        self.pixmaparea.resize( ( self.pixmap_width * self.columns + self.GRID_SPACING * (self.columns-1) ),
                                ( self.pixmap_height * self.rows + self.GRID_SPACING * (self.rows-1) )
        )

        for label in self.widgets:
            label.resize( self.pixmap_width, self.pixmap_height )

        if self.selectionIds != None:
            self.on_reload_images( self.start_i, self.stop_i, self.focus_i )"""

    def on_row_or_column_changed(self):
        for widget in self.widgets:
            widget.clear()
            self.grid.removeWidget(widget)
        del self.widgets[:]

        #self.pixmaparea.resize( ( self.pixmap_width * self.columns + self.GRID_SPACING * (self.columns-1) ),
        #                        ( self.pixmap_height * self.rows + self.GRID_SPACING * (self.rows-1) )
        #)

        for i in xrange(self.rows):
            #self.setRowMinimumHeight(i, self.label_height)
            for j in xrange(self.columns):
                #self.setColumnMinimumWidth(self.label_width)
                ql = QLabel()
                label.resize( self.pixmap_width, self.pixmap_height )
                self.widgets.append(ql)
                self.grid.addWidget(ql, i, j)

        if self.selectionIds != None:
            self.stop_i = min( self.start_i + len(self.widgets), self.selectionIds.shape[0] )
            self.on_reload_images( self.start_i, self.stop_i, self.focus_i )

        """#print self.minimumSizeHint()
        #print self.minimumSize()
        minSizeHint = self.minimumSizeHint()
        minSize_x = max( minSizeHint.width(), self.label_width * self.columns )
        minSize_y = max( minSizeHint.height(), self.label_height * self.rows )
        minSize = QSize(minSize_x, minSize_y)
        self.setMinimumSize(minSize)
        self.resize(minSize)
        for i in xrange(self.rows):
            #self.setRowMinimumHeight(i, self.label_height)
            for j in xrange(self.columns):
                #self.setColumnMinimumWidth(self.label_width)
                ql = QLabel()
                #ql.setFixedSize(self.label_width,self.label_height)
                ql.minimumSize = (self.label_width,self.label_height)
                self.widgets.append(ql)
                self.grid.addWidget(ql, i, j)
        self.update()
        self.on_selection_changed()
        """
    def on_row_changed(self, rows):
        self.rows = rows
        self.on_row_or_column_changed()
    def on_column_changed(self, columns):
        self.columns = columns
        self.on_row_or_column_changed()
    def on_random_changed(self, state):
        self.random = state
        print "on_random_changed"

    def on_channel_changed(self, state):
        print 'channel selection changed'
        self.channelSelection = []
        for checkBox,c in self.channelBoxes.iteritems():
            if checkBox.checkState():
                self.channelSelection.append(c)
        self.channelSelection.sort( cmp=cmp_channels )
        if self.selectionIds != None:
            self.on_reload_images( self.start_i, self.stop_i, self.focus_i )

    def create_frame(self):
        self.grid = QGridLayout()
        self.grid.setSpacing(self.GRID_SPACING)
        
        self.pixmaparea = QWidget()
        self.pixmaparea.setLayout(self.grid)
        
        hbox = QHBoxLayout()
        
        self.previous_button = QPushButton("&Previous")
        self.connect(self.previous_button, SIGNAL('clicked()'), self.on_previous)
        hbox.addWidget(self.previous_button)
        self.next_button = QPushButton("&Next")
        self.connect(self.next_button, SIGNAL('clicked()'), self.on_next)
        hbox.addWidget(self.next_button)
        hbox.addWidget(QLabel("Rows:"))
        self.row_box = QSpinBox()
        self.row_box.setRange(1, 25)
        self.connect(self.row_box, SIGNAL('valueChanged(int)'), self.on_row_changed)
        hbox.addWidget(self.row_box)
        hbox.addWidget(QLabel("Columns:"))
        self.column_box = QSpinBox()
        self.column_box.setRange(1, 25)
        self.connect(self.column_box, SIGNAL('valueChanged(int)'), self.on_column_changed)
        hbox.addWidget(self.column_box)
        hbox.addWidget(QLabel("Random:"))
        self.random_box = QCheckBox()
        self.connect(self.random_box, SIGNAL('stateChanged(int)'), self.on_random_changed)
        hbox.addWidget(self.random_box)
        
        vbox1 = QVBoxLayout()
        vbox1.addLayout(hbox)
        vbox1.addWidget(self.pixmaparea)

        vbox2 = QVBoxLayout()
        groupBox = QGroupBox('Channels:')
        
        for c,name in self.channelDescription.iteritems():
            checkBox = QCheckBox('Show %s' % name)
            self.channelBoxes[checkBox] = c
            self.connect(checkBox, SIGNAL('stateChanged(int)'), self.on_channel_changed)
            vbox2.addWidget(checkBox)
        groupBox.setLayout(vbox2)

        for checkBox,c in self.channelBoxes.iteritems():
            if c in ['R','G','B']:
                checkBox.setChecked(True)
            else:
                checkBox.setChecked(False)

        hbox = QHBoxLayout()
        hbox.addLayout(vbox1)
        hbox.addWidget(groupBox)

        self.setLayout(hbox)
        
        self.rows = 4
        self.columns = 4
        self.row_box.setValue(self.rows)
        self.column_box.setValue(self.columns)
        self.random_box.setCheckState(False)



class GUIWindow(QMainWindow):
    def __init__(self, data, parent=None):
        self.data = data

        QMainWindow.__init__(self, parent)
        self.setWindowTitle('APC Main')

        self.create_menu()
        self.create_main_frame()
        self.create_status_bar()

        self.gallery = GalleryWindow(self.data.channelDescription)

        self.on_draw()

    def closeEvent(self, ce):
        self.gallery.close()
        super(QMainWindow,self).closeEvent(ce)

    def save_plot(self):
        file_choices = "PNG (*.png)|*.png"

        path = unicode(QFileDialog.getSaveFileName(self, 
                        'Save file', '', 
                        file_choices))
        if path:
            self.canvas.print_figure(path, dpi=self.dpi)
            self.statusBar().showMessage('Saved to %s' % path, 2000)

    def on_about(self):
        msg = """ APC GUI """
        QMessageBox.about(self, "About", msg.strip())

    def on_pick(self, event):
        # The event received here is of the type
        # matplotlib.backend_bases.PickEvent
        #
        # It carries lots of information, of which we're using
        # only a small amount here.
        # 
        if event.mouseevent.button == 1:
            lines = event.artist
            ind = event.ind
            """if len(ind) > 1:
                self.statusBar().showMessage(
                    "I'm confused. Which point did you mean?",
                    1500
                )
            else:"""
            mx = event.mouseevent.xdata
            my = event.mouseevent.ydata
            x_lim = self.axes.get_xlim()
            y_lim = self.axes.get_ylim()
            x_weight = 1 / ( x_lim[1] - x_lim[0] )
            y_weight = 1 / ( y_lim[1] - y_lim[0] )
            d = ( x_weight * ( self.x_data - mx ) ) ** 2 + ( y_weight * ( self.y_data - my ) ) ** 2
            min_i = 0
            min_d = d[min_i]
            for i in xrange(d.shape[0]):
                if d[i] < min_d:
                    min_i = i
                    min_d = d[i]
            index = min_i
            #print min_i
            #print 'index=%d, (%f,%f)' % (index,self.x_data[index],self.y_data[index])
            #x = x[ind]
            #y = y[ind]
            #d = (x-mx)**2 + (y-my)**2
            #min_i = 0
            #min_d = d[min_i]
            #for i in xrange(1,d.shape[0]):
            #    if d[i] < min_d:
            #        min_i = i
            #        min_d = d[i]
            #n = ind[min_i]
            #n = ind[0]
            #x = x[n]
            #y = y[n]
            #print x,y,n
            #index = -1
            #for i in xrange(self.x_data.shape[0]):
            #    if x == self.x_data[i] and y == self.y_data[i]:
            #        index = i
            #        break
            #cluster = int(lines.get_label())
            #unsorted_n = sorting_by_cluster[cluster][n]
            #resorted_n = inverse_sorting[unsorted_n]
            #corrected_n = n
            #for i in xrange(clusters.shape[0]):
            #    if i == cluster:
            #        break
            #    corrected_n += cluster_count[i]
            #print 'n=%d, cluster=%d, unsorted_n=%d, resorted_n=%d, corrected_n=%d' % (n,cluster,unsorted_n,resorted_n,corrected_n)
            if index < 0:
                self.statusBar().showMessage('you picked an unknown item')
            else:
                self.statusBar().showMessage('you picked item %d' % index)
            #self.picked_data = (self.x_data[index],self.y_data[index])
            focusId = index
            cluster_i = self.data.partition[focusId]
            j = 0
            for i in xrange(cluster_i):
                j += self.data.cluster_count[i]
            selectionIds = self.data.sorting[ j:j+self.data.cluster_count[cluster_i] ]

            def pixmapFactory(index, width, height, channelSelection, tmp_image_filename=None):
                """filename = None
                path = None
                for (name,prop) in self.data.adc.objects[index].image.properties.iteritems():
                    if name.startswith('FileName_'):
                        filename = prop
                        if path != None:
                            break
                    elif name.startswith('PathName_'):
                        path = prop
                        if filename != None:
                            break
                if filename != None and path != None:
                    filename = os.path.join(path, filename)
                #filename = "/home/benjamin/Desktop/images/HCM_Course_GolgiMorpho/data--final/slide1--black--091106/noc/--W00004--P00003--Z00000--T00000--A568.tif"
                return filename"""

                if not tmp_image_filename:
                    tmp_image_filename = self.TMP_IMAGE_FILENAME_TEMPLATE % ( numpy.random.randint(sys.maxint) )

                objId = int( self.data.features[ index , self.data.adc.objObjectFeatureId ] )
                imgId = int( self.data.features[ index , self.data.adc.objImageFeatureId ] )
                imageFiles = self.data.adc.images[ imgId ].imageFiles

                channel_to_id_map = { 'R':0, 'G':1, 'B':2 }

                for c in channelSelection:
                    if not c in channel_to_id_map:
                        channel_to_id_map[c] = len(channel_to_id_map)

                imgs = [ ]
                for i in xrange( len(channel_to_id_map) ):
                    imgs.append( None )

                xc = int( float( self.data.adc.objects[objId].position_x ) + 0.5 )
                yc = int( float( self.data.adc.objects[objId].position_y ) + 0.5 )
                rect =  (xc - width/2, yc - height/2, xc + width/2, yc + height/2)

                #print rect

                for t in imageFiles:
                    n,c = t
                    if c in channel_to_id_map:
                        if not c in channelSelection:
                            continue
                        i = channel_to_id_map[c]
                        tmp = Image.open( n )
                        if rect[0] < 0 or rect[1] < 0 or rect[2] >= tmp.size[0] or rect[3] >= tmp.size[1]:
                            del tmp
                            return None
                        img = tmp.crop ( rect )
                        img_size = img.size
                        del tmp
                        arr = numpy.array(img.getdata())
                        del img
                        tmp_str = struct.pack('@%dh' % len(arr), *arr)
                        arr = numpy.array(struct.unpack('@%dH' % len(arr), tmp_str))
                        del tmp_str
                        arr = arr - 2**15
                        arr = arr * (2**8-1.0)/(2**12-1.0)
                        #print arr
                        #print c
                        #print n
                        #print numpy.min(arr)
                        #print numpy.max(arr)
                        tmp_str = struct.pack('@%dB' % len(arr), *arr)
                        del arr
                        img = Image.fromstring('L',img_size,tmp_str,"raw","L",0,1)
                        del tmp_str
                        imgs[i] = img
                        del img

                for i in xrange( len( imgs ) ):
                    if not imgs[i]:
                        imgs[i] = Image.new( 'L', ( (rect[2]-rect[0]) , (rect[3]-rect[1]) ), 0)

                mode = 'RGB'
                img = Image.merge( mode, imgs[:3] )

                if len(imgs) > 3:
                    del imgs[:3]
                    while len(imgs) > 1:
                        img1,img2 = imgs[0],imgs[1]
                        tmp = ImageChops.lighter( img1, img2 )
                        del imgs[0], img1, img2
                        imgs[0] = tmp
                    imgs[0] = imgs[0].convert( mode )
                    tmp = ImageChops.lighter( img, imgs[0])
                    del img
                    img = tmp

                del imgs[:]
                del imgs

                img.save( tmp_image_filename )
                del img

                qtimg = QImage( tmp_image_filename )
                pix = QPixmap.fromImage( qtimg )
                #pix = QPixmap( tmp_image_filename )

                return pix

            self.gallery.on_selection_changed(focusId, selectionIds, pixmapFactory)
            self.gallery.show()
            self.picked_index = index
            self.picked_cluster = cluster_i
            #self.picked_index = index - j
            #print ('pick event (%f,%f): ' %(event.mouseevent.xdata,event.mouseevent.ydata)) + str(event)
            #for i in ind:
            #    msg = 'picked line (%f,%f),index=%d' % (x[i],y[i],i)
            #    print msg
    
    def on_draw(self):
        """ Redraws the figure
        """
        #self.fig.clear()
        #plt.figure(self.fig)
        #symbols = ['bo','gp','rs','ch','mD','y1']
        self.axes.clear()
        colors = ['b','g','c','m','y','r']
        symbols = ['s','+','*','d']
        markers = []
        for s in symbols:
            for c in colors:
                markers.append(s+c)
        picked_symbol = 'rp'
        if len(self.x_data_by_cluster) == len(self.y_data_by_cluster):
            for i in xrange(len(self.x_data_by_cluster)):
                #import pdb; pdb.set_trace()
                if self.x_data_by_cluster[i].shape != self.y_data_by_cluster[i].shape:
                    raise Exception('inconsistent data')
                self.axes.plot(
                        self.x_data_by_cluster[i],
                        self.y_data_by_cluster[i],
                        markers[ min( i, len(markers)-1 ) ],
                        picker = 4,
                        label = '%d' % i
                )
            #if self.picked_index < 0:
            #    self.axes.plot(self.x_data[self.picked_index],
            #                   self.y_data[self.picked_index],
            #                   picked_symbol, label = 'selected')
	
        #pyplot.plot(X[:,0],X[:,1],'o')
        #self.fig.show()
        #plt.show()
#===============================================================================
#         
#         # clear the axes and redraw the plot anew
#         #
#         self.axes.clear()        
#         self.axes.grid(self.grid_cb.isChecked())
#         
#         self.axes.bar(
#             left=x, 
#             height=self.data, 
#             width=self.slider.value() / 100.0, 
#             align='center', 
#             alpha=0.44,
#             picker=5)
#===============================================================================
        
        self.canvas.draw()

    def select_data(self, data_name):
        data_name = str(data_name)
        if data_name.startswith('feature '):
            tmp = self.data.features[ :,int(data_name[len('feature '):]) ]
        elif data_name.startswith('mahal '):
            tmp = self.data.mahalPoints[ :,int(data_name[len('mahal '):]) ]
        #elif data_name.startswith('X '):
        #    tmp = self.data.X[ :,int(data_name[len('X '):]) ]
        elif data_name == 'n':
            tmp = numpy.zeros(self.data.features.shape[0])
            for i in xrange(tmp.shape[0]):
                tmp[i] = i
        elif data_name == 'n_sorted':
            tmp = numpy.zeros(self.data.features.shape[0])
            for i in xrange(tmp.shape[0]):
                tmp[i] = self.data.inverse_sorting[i]
        else:
            print 'data_name=%s' % data_name
            return []
            
        d = []
        j = 0
        for i in xrange(self.data.clusters.shape[0]):
            d.append(tmp[ self.data.sorting[ j:j+self.data.cluster_count[i] ],: ] )
            j += self.data.cluster_count[i]
        return tmp,d
        
    def on_x_combo_changed(self, index):
        name = self.x_combo.itemData(index).toString()
        self.x_data,self.x_data_by_cluster = self.select_data(name)
        self.on_draw()
    
    def on_y_combo_changed(self, index):
        name = self.y_combo.itemData(index).toString()
        self.y_data,self.y_data_by_cluster = self.select_data(name)
        self.on_draw()
    
    def create_main_frame(self):
        self.main_frame = QWidget()
        
        # Create the mpl Figure and FigCanvas objects. 
        # 5x4 inches, 100 dots-per-inch
        #
        self.dpi = 100
        #self.fig = Figure((5.0, 4.0), dpi=self.dpi)
        self.fig = pyplot.figure()
        self.canvas = FigureCanvas(self.fig)
        self.canvas.setParent(self.main_frame)
        
        # Since we have only one plot, we can use add_axes 
        # instead of add_subplot, but then the subplot
        # configuration tool in the navigation toolbar wouldn't
        # work.
        #
        self.axes = self.fig.add_subplot(111)
        
        # Bind the 'pick' event for clicking on one of the bars
        #
        self.canvas.mpl_connect('pick_event', self.on_pick)
        
        # Create the navigation toolbar, tied to the canvas
        #
        self.mpl_toolbar = NavigationToolbar(self.canvas, self.main_frame)
        
        # Other GUI controls
        # 
        self.x_data_by_cluster = []
        self.y_data_by_cluster = []
        self.picked_index = -1
        self.picked_cluster = -1
        self.x_combo = QComboBox()
        self.y_combo = QComboBox()

        self.x_combo.addItem('n','n')
        self.y_combo.addItem('n','n')

        self.x_combo.addItem('sorted n','n_sorted')
        self.y_combo.addItem('sorted n','n_sorted')
        #for i in xrange(self.data.X.shape[1]):
        #    self.x_combo.addItem('X[%d]' % i,'X %d' % i)
        #    self.y_combo.addItem('X[%d]' % i,'X %d' % i)

        for i in xrange(self.data.mahalPoints.shape[1]):
            self.x_combo.addItem('mahal_%s' % self.data.featureNames[i],'mahal %d' % i)
            self.y_combo.addItem('mahal_%s' % self.data.featureNames[i],'mahal %d' % i)

        for name,featureId in self.data.adc.objFeatureIds.iteritems():
            self.x_combo.addItem(name,'feature %d' % featureId)
            self.y_combo.addItem(name,'feature %d' % featureId)

        self.x_combo.connect(self.x_combo, SIGNAL('currentIndexChanged(int)'), self.on_x_combo_changed)
        self.y_combo.connect(self.y_combo, SIGNAL('currentIndexChanged(int)'), self.on_y_combo_changed)
        self.x_combo.setCurrentIndex(1)
        self.y_combo.setCurrentIndex(2)
        
        #
        # Layout with box sizers
        # 
        hbox = QHBoxLayout()
        
        hbox1 = QVBoxLayout()
        hbox1.addWidget(QLabel('x-Axis'))
        hbox1.addWidget(self.x_combo)
        hbox2 = QVBoxLayout()
        hbox2.addWidget(QLabel('y-Axis'))
        hbox2.addWidget(self.y_combo)
        
        vbox1 = QVBoxLayout()
        vbox1.addLayout(hbox1)
        vbox1.addLayout(hbox2)
        
        hbox.addLayout(vbox1)
        
        vbox = QVBoxLayout()
        vbox.addWidget(self.canvas)
        vbox.addWidget(self.mpl_toolbar)
        vbox.addLayout(hbox)
        vbox.setStretch(0,1)
        
        self.main_frame.setLayout(vbox)
        self.setCentralWidget(self.main_frame)
    
    def create_status_bar(self):
        self.status_text = QLabel("This is a demo")
        self.statusBar().addWidget(self.status_text, 1)
        
    def create_menu(self):        
        self.file_menu = self.menuBar().addMenu("&File")
        
        load_file_action = self.create_action("&Save plot",
            shortcut="Ctrl+S", slot=self.save_plot, 
            tip="Save the plot")
        quit_action = self.create_action("&Quit", slot=self.close, 
            shortcut="Ctrl+Q", tip="Close the application")
        
        self.add_actions(self.file_menu, 
            (load_file_action, None, quit_action))
        
        self.help_menu = self.menuBar().addMenu("&Help")
        about_action = self.create_action("&About", 
            shortcut='F1', slot=self.on_about, 
            tip='About the demo')
        
        self.add_actions(self.help_menu, (about_action,))

    def add_actions(self, target, actions):
        for action in actions:
            if action is None:
                target.addSeparator()
            else:
                target.addAction(action)

    def create_action(  self, text, slot=None, shortcut=None, 
                        icon=None, tip=None, checkable=False, 
                        signal="triggered()"):
        action = QAction(text, self)
        if icon is not None:
            action.setIcon(QIcon(":/%s.png" % icon))
        if shortcut is not None:
            action.setShortcut(shortcut)
        if tip is not None:
            action.setToolTip(tip)
            action.setStatusTip(tip)
        if slot is not None:
            self.connect(action, SIGNAL(signal), slot)
        if checkable:
            action.setCheckable(True)
        return action



class GUIData:
    pass



class GUI:
    
    def __init__(self, adc, features, mahalPoints, featureNames, channelDescription, partition, sorting, inverse_sorting, clusters, cluster_count, argv):
        tmp = GUIData()
        tmp.adc = adc
        tmp.features = features
        tmp.mahalPoints = mahalPoints
        tmp.featureNames = featureNames
        tmp.channelDescription = channelDescription
        tmp.partition = partition
        tmp.sorting = sorting
        tmp.inverse_sorting = inverse_sorting
        tmp.clusters = clusters
        tmp.cluster_count = cluster_count
        self.app = QApplication(argv)
        self.mainwindow = GUIWindow(tmp)
        self.mainwindow.show()
        self.app.exec_()
        self.mainwindow.close()
